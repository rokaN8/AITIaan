<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spooky Breakout - AI-Enhanced Brick Ball Game</title>
    <style>
        @font-face {
            font-family: 'ScaryFont';
            src: url('assets/font/scaryfont.ttf') format('truetype');
            font-display: swap;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background: #000000;
            color: #ffffff;
            font-family: 'ScaryFont', 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameCanvas {
            border: 2px solid #cc0000;
            background: #000;
            box-shadow: 0 0 20px rgba(204, 0, 0, 0.5);
        }
        
        .ui {
            margin: 10px 0;
            font-size: 20px;
            text-align: center;
        }
        
        .game-info {
            display: flex;
            gap: 30px;
            margin-bottom: 10px;
        }
        
        .power-up-timer {
            background: rgba(204, 0, 0, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            margin: 5px;
            border: 1px solid #cc0000;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
        }
        
        .leaderboard {
            width: 275px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #cc0000;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(204, 0, 0, 0.3);
        }
        
        .legend {
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #cc0000;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(204, 0, 0, 0.3);
        }
        
        .legend h3 {
            margin: 0 0 15px 0;
            color: #cc0000;
            text-align: center;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(204, 0, 0, 0.8);
        }
        
        .legend-section {
            margin-bottom: 20px;
        }
        
        .legend-section h4 {
            margin: 0 0 10px 0;
            color: #ff4444;
            font-size: 16px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }
        
        .legend-icon {
            width: 40px;
            height: 25px;
            margin-right: 12px;
            border: 1px solid #666;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .legend-description {
            flex: 1;
            font-size: 12px;
            line-height: 1.3;
        }
        
        .legend-name {
            color: #fff;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .legend-details {
            color: #ccc;
        }
        
        .leaderboard h3 {
            margin: 0 0 15px 0;
            color: #cc0000;
            text-align: center;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(204, 0, 0, 0.8);
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            font-size: 14px;
        }
        
        .leaderboard-entry:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #888;
            width: 25px;
        }
        
        .leaderboard-name {
            color: #fff;
            flex: 1;
            text-align: center;
        }
        
        .leaderboard-score {
            color: #cc0000;
            font-weight: bold;
        }
        
        .leaderboard-entry.empty .leaderboard-name,
        .leaderboard-entry.empty .leaderboard-score {
            color: #444;
        }
        
        .reset-button {
            width: 100%;
            margin: 15px 0 5px 0;
            padding: 8px 15px;
            background: #222;
            color: #cc0000;
            border: 2px solid #cc0000;
            font-size: 14px;
        }
        
        .reset-button:hover {
            background: #333;
            border-color: #ff4444;
            color: #ff4444;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #ff4444;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        
        .name-entry {
            margin: 20px 0;
        }
        
        .name-entry input {
            background: #333;
            color: #fff;
            border: 2px solid #cc0000;
            padding: 10px;
            font-family: inherit;
            font-size: 18px;
            text-align: center;
            text-transform: uppercase;
            max-width: 80px;
            letter-spacing: 2px;
        }
        
        .name-entry input:focus {
            outline: none;
            border-color: #ff4444;
            box-shadow: 0 0 10px rgba(204, 0, 0, 0.5);
        }
        
        button {
            background: #333;
            color: #fff;
            border: 2px solid #666;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 16px;
        }
        
        button:hover {
            background: #555;
            border-color: #888;
        }
        
        button:disabled {
            background: #222;
            color: #666;
            border-color: #444;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>Spooky Breakout</h1>
    <div class="ui">
        <div class="game-info">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Level: <span id="level">1</span></div>
            <div>Version: <span id="version">1.0.0</span></div>
        </div>
    </div>
    
    <div class="game-container">
        <div class="leaderboard">
            <h3>HIGH SCORES</h3>
            <div id="leaderboardList">
                <!-- Leaderboard entries will be populated here -->
            </div>
            <div id="powerUpTimers"></div>
            <button onclick="resetLeaderboard()" class="reset-button">Reset Scores</button>
            
            <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #333; font-size: 12px; line-height: 1.4;">
                <div style="margin-bottom: 8px;">• Use ← → arrow keys or mouse to control paddle</div>
                <div style="margin-bottom: 8px;">• Press SPACE to launch ball</div>
                <div style="margin-bottom: 8px;">• Press B to explode ball (costs a life!)</div>
                <div style="margin-bottom: 8px;">• Press M to toggle sound</div>
                <div style="margin-bottom: 8px;">• Press D for developer mode (5 bricks, no score)</div>
                <div style="margin-bottom: 8px;">• Developer mode: +/- keys change level, [ ] keys adjust lives</div>
                <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #333; color: #888; font-size: 10px;">
                    Background by <a href="https://deepai.org/" target="_blank" style="color: #cc0000; text-decoration: none;">deepai.org</a>
                </div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="880" height="660"></canvas>
        
        <div class="legend">
            <h3>GAME LEGEND</h3>
            
            <div class="legend-section">
                <h4>Power-ups</h4>
                <div class="legend-item">
                    <div class="legend-icon" id="widePaddleIcon"></div>
                    <div class="legend-description">
                        <div class="legend-name">Wide Paddle</div>
                        <div class="legend-details">Expands paddle width for 15 seconds</div>
                    </div>
                </div>
                <div class="legend-item">
                    <div class="legend-icon" id="slowBallIcon"></div>
                    <div class="legend-description">
                        <div class="legend-name">Slow Ball</div>
                        <div class="legend-details">Reduces ball speed for 20 seconds</div>
                    </div>
                </div>
            </div>
            
            <div class="legend-section">
                <h4>Special Blocks</h4>
                <div class="legend-item">
                    <div class="legend-icon" id="ghostBrickIcon"></div>
                    <div class="legend-description">
                        <div class="legend-name">Ghost Brick</div>
                        <div class="legend-details">Phases in/out every 5 seconds, 1 hit, 50 points</div>
                    </div>
                </div>
                <div class="legend-item">
                    <div class="legend-icon" id="vampireBrickIcon"></div>
                    <div class="legend-description">
                        <div class="legend-name">Vampire Brick</div>
                        <div class="legend-details">Regenerates health every 8 seconds, 2 hits, 60 points</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="ui">
        <button id="soundToggle" onclick="toggleSound()">🔊 Sound: ON</button>
    </div>
    
    <div id="gameOverScreen" class="game-over">
        <h2>Game Over!</h2>
        <div>Final Score: <span id="finalScore">0</span></div>
        <button onclick="restartGame()">Play Again</button>
    </div>

    <!-- Audio Elements -->
    <audio id="backgroundMusic" preload="auto" loop>
        <source src="assets/audio/background.mp3" type="audio/mpeg">
    </audio>
    <audio id="endGameSound" preload="auto">
        <source src="assets/audio/endgame.mp3" type="audio/mpeg">
    </audio>
    <audio id="explosionSound" preload="auto">
        <source src="assets/audio/explosion.mp3" type="audio/mpeg">
    </audio>
    <audio id="ghostSound" preload="auto">
        <source src="assets/audio/ghostsound.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Version tracking
        const GAME_VERSION = '1.13.0';
        
        // Game canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const CANVAS_WIDTH = 880;
        const CANVAS_HEIGHT = 660;
        const PADDLE_WIDTH = 110;
        const PADDLE_HEIGHT = 17;
        const BALL_RADIUS = 9;
        const BRICK_WIDTH = 83;
        const BRICK_HEIGHT = 22;
        const BRICK_ROWS = 6;
        const BRICK_COLS = 9;
        const BRICK_PADDING = 6;
        const BRICK_OFFSET_TOP = 66;
        const BRICK_OFFSET_LEFT = 39;
        
        // Game state
        let gameState = 'waiting'; // 'waiting', 'playing', 'gameOver'
        let lives = 3;
        let score = 0;
        let level = 1;
        let lastTime = 0;
        let developerMode = false;
        
        // Input handling
        const keys = {
            left: false,
            right: false,
            space: false
        };
        
        let mouseX = CANVAS_WIDTH / 2;
        let useMouseControl = false;
        
        // Game objects
        const paddle = {
            x: CANVAS_WIDTH / 2 - PADDLE_WIDTH / 2,
            y: CANVAS_HEIGHT - 30,
            width: PADDLE_WIDTH,
            height: PADDLE_HEIGHT,
            speed: 7,
            originalWidth: PADDLE_WIDTH
        };
        
        const ball = {
            x: CANVAS_WIDTH / 2,
            y: paddle.y - BALL_RADIUS - 1,
            vx: 0,
            vy: 0,
            radius: BALL_RADIUS,
            speed: 4,
            originalSpeed: 4,
            onPaddle: true
        };
        
        // Brick types - Spooky theme: white to red gradient + supernatural bricks
        const brickTypes = {
            white: { hits: 1, points: 10, color: '#ffffff' },
            lightGray: { hits: 1, points: 20, color: '#cccccc' },
            darkGray: { hits: 2, points: 30, color: '#666666' },
            bloodRed: { hits: 2, points: 40, color: '#cc0000' },
            ghost: { hits: 1, points: 50, color: '#88ccff', special: 'ghost' },
            vampire: { hits: 2, points: 60, color: '#660033', special: 'vampire' }
        };
        
        // Bricks array
        let bricks = [];
        
        // Power-ups
        const powerUps = [];
        const activePowerUps = [];
        
        const powerUpTypes = {
            widePaddle: { 
                duration: 15000, 
                color: '#cc0000',
                name: 'Wide Paddle'
            },
            slowBall: { 
                duration: 20000, 
                color: '#ff4444',
                name: 'Slow Ball'
            }
        };
        
        // AI Performance Tracking
        const playerMetrics = {
            ballsLost: 0,
            bricksHit: 0,
            totalBallBounces: 0,
            paddleHits: 0,
            paddleMisses: 0,
            timeSpentOnLevel: 0,
            consecutiveDeaths: 0,
            levelStartTime: Date.now(),
            lastBallLoss: 0,
            recentPerformance: [] // Track recent performance windows
        };
        
        // AI Assistance System
        function calculateAccuracy() {
            const totalAttempts = playerMetrics.paddleHits + playerMetrics.paddleMisses;
            if (totalAttempts === 0) return 1.0;
            return playerMetrics.paddleHits / totalAttempts;
        }
        
        function getStruggleLevel() {
            const accuracy = calculateAccuracy();
            const timeSinceStart = Date.now() - playerMetrics.levelStartTime;
            const avgTimePerBrick = timeSinceStart / Math.max(1, playerMetrics.bricksHit);
            
            // High struggle indicators
            if (playerMetrics.consecutiveDeaths >= 3 || accuracy < 0.3) return 2;
            
            // Medium struggle indicators  
            if (playerMetrics.consecutiveDeaths >= 2 || accuracy < 0.6 || avgTimePerBrick > 10000) return 1;
            
            // No struggle
            return 0;
        }
        
        function getAssistanceLevel() {
            return getStruggleLevel();
        }
        
        function shouldSpawnHelpfulPowerUp() {
            const struggleLevel = getStruggleLevel();
            const baseChance = 0.1;
            
            // Increase power-up chance based on struggle
            switch(struggleLevel) {
                case 2: return Math.random() < baseChance * 3; // 30% chance
                case 1: return Math.random() < baseChance * 2; // 20% chance
                default: return Math.random() < baseChance;    // 10% chance
            }
        }
        
        function applyPhysicsAssistance() {
            const assistanceLevel = getAssistanceLevel();
            
            if (assistanceLevel === 0) return; // No help needed
            
            // Subtle paddle magnetism for struggling players
            if (assistanceLevel >= 1 && !ball.onPaddle) {
                const paddleCenter = paddle.x + paddle.width / 2;
                const ballToPaddle = paddleCenter - ball.x;
                const distance = Math.abs(ballToPaddle);
                
                // Only apply if ball is reasonably close and moving toward paddle
                if (distance < 100 && ball.vy > 0 && ball.y > paddle.y - 100) {
                    const magnetStrength = assistanceLevel === 2 ? 0.3 : 0.15;
                    ball.vx += (ballToPaddle > 0 ? magnetStrength : -magnetStrength);
                }
            }
        }
        
        function applyCollisionAssistance() {
            const assistanceLevel = getAssistanceLevel();
            
            if (assistanceLevel === 0) return false; // No help
            
            // Expand collision detection for struggling players
            const expansion = assistanceLevel === 2 ? 8 : 4;
            
            // Check expanded paddle collision
            if (ball.y + ball.radius >= paddle.y - expansion &&
                ball.y - ball.radius <= paddle.y + paddle.height + expansion &&
                ball.x + ball.radius >= paddle.x - expansion &&
                ball.x - ball.radius <= paddle.x + paddle.width + expansion) {
                
                // Only help if ball would have missed normally
                if (!(ball.y + ball.radius >= paddle.y &&
                      ball.y - ball.radius <= paddle.y + paddle.height &&
                      ball.x >= paddle.x &&
                      ball.x <= paddle.x + paddle.width)) {
                    
                    // Apply helpful bounce
                    const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                    ball.vx = hitPos * 4;
                    ball.vy = -Math.abs(ball.vy);
                    
                    if (Math.abs(ball.vy) < 3) {
                        ball.vy = -3;
                    }
                    
                    ball.y = paddle.y - ball.radius;
                    playerMetrics.paddleHits++;
                    playerMetrics.totalBallBounces++;
                    
                    return true; // Assistance was applied
                }
            }
            
            return false;
        }
        
        // Particles for visual effects
        const particles = [];
        const ballTrailParticles = [];
        
        // Screen shake
        let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
        
        // Sound System
        let audioContext = null;
        let soundEnabled = true;
        let backgroundMusic = null;
        let endGameSound = null;
        let explosionSound = null;
        let ghostSound = null;
        let musicStarted = false;
        
        // Game over image
        let gameOverImage = null;
        let imageLoaded = false;
        
        // Background image
        let backgroundImage = null;
        let backgroundImageLoaded = false;
        
        // Ghost sprite system
        let ghostImage = null;
        let ghostImageLoaded = false;
        const floatingGhosts = [];
        let lastGhostSpawn = 0;
        let lastGhostSound = 0;
        const GHOST_SPAWN_INTERVAL = 8000; // 8 seconds between ghost spawns
        const GHOST_SOUND_INTERVAL = 25000; // 25+ seconds between ghost sounds
        const MAX_GHOSTS = 8; // Maximum number of floating ghosts
        
        // Leaderboard System
        const LEADERBOARD_KEY = 'spookyBreakoutLeaderboard';
        const OLD_LEADERBOARD_KEY = 'adaptiveBreakoutLeaderboard';
        const MAX_LEADERBOARD_ENTRIES = 10;
        let leaderboard = [];
        let isNewHighScore = false;
        let playerName = '';
        
        const soundManager = {
            init() {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    soundEnabled = false;
                }
                
                // Initialize HTML5 audio elements
                backgroundMusic = document.getElementById('backgroundMusic');
                endGameSound = document.getElementById('endGameSound');
                explosionSound = document.getElementById('explosionSound');
                ghostSound = document.getElementById('ghostSound');
                
                // Set volume levels
                if (backgroundMusic) {
                    backgroundMusic.volume = 0.3; // Lower volume for ambiance
                }
                if (endGameSound) {
                    endGameSound.volume = 0.7; // Higher volume for dramatic effect
                }
                if (explosionSound) {
                    explosionSound.volume = 0.8; // High volume for explosion impact
                }
                if (ghostSound) {
                    ghostSound.volume = 0.15; // Half the volume of background music
                }
            },
            
            startBackgroundMusic() {
                if (!soundEnabled || !backgroundMusic || musicStarted) return;
                
                try {
                    backgroundMusic.currentTime = 0;
                    backgroundMusic.play().catch(e => {
                        console.warn('Background music failed to play:', e);
                    });
                    musicStarted = true;
                } catch (e) {
                    console.warn('Background music error:', e);
                }
            },
            
            stopBackgroundMusic() {
                if (!backgroundMusic) return;
                
                try {
                    backgroundMusic.pause();
                    backgroundMusic.currentTime = 0;
                    musicStarted = false;
                } catch (e) {
                    console.warn('Background music stop error:', e);
                }
            },
            
            playEndGameSound() {
                if (!soundEnabled || !endGameSound) return;
                
                try {
                    endGameSound.currentTime = 0;
                    endGameSound.play().catch(e => {
                        console.warn('End game sound failed to play:', e);
                    });
                } catch (e) {
                    console.warn('End game sound error:', e);
                }
            },
            
            playBrickHit() {
                if (!audioContext || !soundEnabled) return;
                
                // Dull thump sound
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
                oscillator.type = 'square';
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            },
            
            playBrickBreak() {
                if (!audioContext || !soundEnabled) return;
                
                // Glass shattering sound
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const oscillator3 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                // Multiple high frequencies for glass-like sound
                oscillator1.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator2.frequency.setValueAtTime(1200, audioContext.currentTime);
                oscillator3.frequency.setValueAtTime(1600, audioContext.currentTime);
                
                oscillator1.type = 'triangle';
                oscillator2.type = 'triangle';
                oscillator3.type = 'triangle';
                
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(400, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator1.connect(filter);
                oscillator2.connect(filter);
                oscillator3.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator1.start();
                oscillator2.start();
                oscillator3.start();
                
                oscillator1.stop(audioContext.currentTime + 0.3);
                oscillator2.stop(audioContext.currentTime + 0.3);
                oscillator3.stop(audioContext.currentTime + 0.3);
            },
            
            playLifeLost() {
                if (!audioContext || !soundEnabled) return;
                
                // High pitch violin screech
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                oscillator.frequency.setValueAtTime(1200, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(2000, audioContext.currentTime + 0.5);
                oscillator.type = 'sawtooth';
                
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(1500, audioContext.currentTime);
                filter.Q.setValueAtTime(10, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.8);
            },
            
            playExplosion() {
                if (!soundEnabled || !explosionSound) return;
                
                try {
                    explosionSound.currentTime = 0;
                    explosionSound.play().catch(e => {
                        console.warn('Explosion sound failed to play:', e);
                    });
                } catch (e) {
                    console.warn('Explosion sound error:', e);
                }
            },
            
            playGhostSound() {
                if (!soundEnabled || !ghostSound) return;
                
                try {
                    ghostSound.currentTime = 0;
                    ghostSound.play().catch(e => {
                        console.warn('Ghost sound failed to play:', e);
                    });
                } catch (e) {
                    console.warn('Ghost sound error:', e);
                }
            },
            
            toggleSound() {
                soundEnabled = !soundEnabled;
                
                // Handle background music based on sound state
                if (!soundEnabled) {
                    this.stopBackgroundMusic();
                } else if (gameState === 'playing' || gameState === 'waiting') {
                    // Only restart music if we're in an active game state
                    if (gameState === 'playing') {
                        this.startBackgroundMusic();
                    }
                }
                
                return soundEnabled;
            }
        };
        
        // Star system for spooky background
        const stars = [];
        
        // Initialize stars
        function initStars() {
            for (let i = 0; i < 75; i++) {
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 0.5 + 0.2,
                    opacity: Math.random() * 0.7 + 0.3,
                    twinklePhase: Math.random() * Math.PI * 2,
                    twinkleSpeed: Math.random() * 0.02 + 0.01
                });
            }
        }
        
        // Update stars
        function updateStars() {
            for (let star of stars) {
                star.x -= star.speed;
                star.twinklePhase += star.twinkleSpeed;
                star.opacity = 0.3 + 0.7 * (Math.sin(star.twinklePhase) * 0.5 + 0.5);
                
                // Wrap around when star exits left side
                if (star.x < -5) {
                    star.x = CANVAS_WIDTH + 5;
                    star.y = Math.random() * CANVAS_HEIGHT;
                }
            }
        }
        
        // Draw stars
        function drawStars() {
            for (let star of stars) {
                ctx.globalAlpha = star.opacity;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = true;
                    useMouseControl = false;
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    keys.right = true;
                    useMouseControl = false;
                    e.preventDefault();
                    break;
                case 'Space':
                    keys.space = true;
                    e.preventDefault();
                    break;
                case 'KeyB':
                    if (gameState === 'playing' && !ball.onPaddle) {
                        explodeBall();
                    }
                    e.preventDefault();
                    break;
                case 'KeyM':
                    toggleSound();
                    e.preventDefault();
                    break;
                case 'KeyD':
                    activateDeveloperMode();
                    e.preventDefault();
                    break;
                case 'Minus':
                    if (developerMode) changeDeveloperLevel(-1);
                    e.preventDefault();
                    break;
                case 'Equal': // + key
                    if (developerMode) changeDeveloperLevel(1);
                    e.preventDefault();
                    break;
                case 'BracketLeft': // [ key
                    if (developerMode) adjustDeveloperLives(-1);
                    e.preventDefault();
                    break;
                case 'BracketRight': // ] key
                    if (developerMode) adjustDeveloperLives(1);
                    e.preventDefault();
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'Space':
                    keys.space = false;
                    break;
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            useMouseControl = true;
        });
        
        // Leaderboard Management Functions
        function loadLeaderboard() {
            try {
                // Try to load from new key first
                let saved = localStorage.getItem(LEADERBOARD_KEY);
                if (saved) {
                    leaderboard = JSON.parse(saved);
                } else {
                    // Check for old key and migrate
                    const oldSaved = localStorage.getItem(OLD_LEADERBOARD_KEY);
                    if (oldSaved) {
                        leaderboard = JSON.parse(oldSaved);
                        // Save to new key
                        localStorage.setItem(LEADERBOARD_KEY, oldSaved);
                        // Remove old key
                        localStorage.removeItem(OLD_LEADERBOARD_KEY);
                        console.log('Migrated leaderboard from Adaptive Breakout to Spooky Breakout');
                    } else {
                        leaderboard = [];
                    }
                }
            } catch (e) {
                console.warn('Failed to load leaderboard:', e);
                leaderboard = [];
            }
        }
        
        function saveLeaderboard() {
            try {
                localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboard));
            } catch (e) {
                console.warn('Failed to save leaderboard:', e);
            }
        }
        
        function isHighScore(score) {
            if (leaderboard.length < MAX_LEADERBOARD_ENTRIES) {
                return true;
            }
            return score > leaderboard[leaderboard.length - 1].score;
        }
        
        function addToLeaderboard(name, score) {
            const entry = {
                name: name.toUpperCase().substring(0, 3),
                score: score,
                date: Date.now()
            };
            
            leaderboard.push(entry);
            leaderboard.sort((a, b) => b.score - a.score);
            
            if (leaderboard.length > MAX_LEADERBOARD_ENTRIES) {
                leaderboard = leaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
            }
            
            saveLeaderboard();
            updateLeaderboardDisplay();
        }
        
        function updateLeaderboardDisplay() {
            const listElement = document.getElementById('leaderboardList');
            listElement.innerHTML = '';
            
            // Always show exactly 10 entries
            for (let i = 0; i < MAX_LEADERBOARD_ENTRIES; i++) {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'leaderboard-entry';
                
                const rankSpan = document.createElement('span');
                rankSpan.className = 'leaderboard-rank';
                rankSpan.textContent = `${i + 1}.`;
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'leaderboard-name';
                
                const scoreSpan = document.createElement('span');
                scoreSpan.className = 'leaderboard-score';
                
                if (i < leaderboard.length) {
                    // Real entry
                    const entry = leaderboard[i];
                    nameSpan.textContent = entry.name;
                    scoreSpan.textContent = entry.score.toLocaleString();
                } else {
                    // Empty slot
                    entryDiv.classList.add('empty');
                    nameSpan.textContent = '---';
                    scoreSpan.textContent = '---';
                }
                
                entryDiv.appendChild(rankSpan);
                entryDiv.appendChild(nameSpan);
                entryDiv.appendChild(scoreSpan);
                
                listElement.appendChild(entryDiv);
            }
        }
        
        function resetLeaderboard() {
            if (confirm('Are you sure you want to reset all high scores? This cannot be undone.')) {
                leaderboard = [];
                saveLeaderboard();
                updateLeaderboardDisplay();
            }
        }
        
        function validatePlayerName(name) {
            // Remove non-alphanumeric characters and limit to 3 characters
            return name.replace(/[^A-Z0-9]/g, '').substring(0, 3);
        }
        
        // Legend rendering functions
        function renderLegendIcons() {
            // Wide Paddle Icon
            const widePaddleIcon = document.getElementById('widePaddleIcon');
            if (widePaddleIcon) {
                widePaddleIcon.style.background = 'linear-gradient(to right, #cc0000, #ff4444)';
                widePaddleIcon.style.border = '2px solid #cc0000';
                widePaddleIcon.style.position = 'relative';
                widePaddleIcon.innerHTML = '<div style="width: 80%; height: 40%; background: #000; margin: auto; margin-top: 30%; border: 1px solid #fff;"></div>';
            }
            
            // Slow Ball Icon
            const slowBallIcon = document.getElementById('slowBallIcon');
            if (slowBallIcon) {
                slowBallIcon.style.background = 'radial-gradient(circle, #ff4444, #cc0000)';
                slowBallIcon.style.border = '2px solid #ff4444';
                slowBallIcon.style.borderRadius = '50%';
                slowBallIcon.style.position = 'relative';
                // Add clock-like markings
                slowBallIcon.innerHTML = `
                    <div style="position: absolute; top: 2px; left: 50%; width: 1px; height: 8px; background: #fff; transform: translateX(-50%);"></div>
                    <div style="position: absolute; bottom: 2px; left: 50%; width: 1px; height: 8px; background: #fff; transform: translateX(-50%);"></div>
                    <div style="position: absolute; top: 50%; left: 2px; width: 8px; height: 1px; background: #fff; transform: translateY(-50%);"></div>
                    <div style="position: absolute; top: 50%; right: 2px; width: 8px; height: 1px; background: #fff; transform: translateY(-50%);"></div>
                `;
            }
            
            // Ghost Brick Icon
            const ghostBrickIcon = document.getElementById('ghostBrickIcon');
            if (ghostBrickIcon) {
                ghostBrickIcon.style.background = 'linear-gradient(45deg, #88ccff, #aaddff)';
                ghostBrickIcon.style.border = '2px solid #88ccff';
                ghostBrickIcon.style.opacity = '0.7';
                ghostBrickIcon.style.boxShadow = '0 0 8px #88ccff';
                ghostBrickIcon.style.animation = 'ghostPulse 2s ease-in-out infinite';
            }
            
            // Vampire Brick Icon
            const vampireBrickIcon = document.getElementById('vampireBrickIcon');
            if (vampireBrickIcon) {
                vampireBrickIcon.style.background = 'linear-gradient(45deg, #660033, #880044)';
                vampireBrickIcon.style.border = '2px solid #660033';
                vampireBrickIcon.style.position = 'relative';
                vampireBrickIcon.style.animation = 'vampirePulse 1.5s ease-in-out infinite';
                // Add blood drip effect
                vampireBrickIcon.innerHTML = '<div style="position: absolute; bottom: -2px; left: 50%; width: 2px; height: 6px; background: #cc0000; transform: translateX(-50%);"></div>';
            }
            
            // Add CSS animations for special bricks
            if (!document.getElementById('legendAnimations')) {
                const style = document.createElement('style');
                style.id = 'legendAnimations';
                style.textContent = `
                    @keyframes ghostPulse {
                        0%, 100% { opacity: 0.7; }
                        50% { opacity: 0.3; }
                    }
                    @keyframes vampirePulse {
                        0%, 100% { box-shadow: 0 0 5px #660033; }
                        50% { box-shadow: 0 0 15px #cc0000; }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Initialize game
        function init() {
            // Log version information for debugging
            console.log(`Spooky Breakout v${GAME_VERSION} - AI-Enhanced Brick Ball Game`);
            console.log('Game initialized successfully');
            
            // Update version display
            document.getElementById('version').textContent = GAME_VERSION;
            
            // Initialize sound system
            soundManager.init();
            
            // Load game over image
            gameOverImage = new Image();
            gameOverImage.onload = function() {
                imageLoaded = true;
                console.log('Game over image loaded successfully');
            };
            gameOverImage.onerror = function() {
                console.warn('Failed to load game over image');
                imageLoaded = false;
            };
            gameOverImage.src = 'assets/sprites/face.png';
            
            // Load background image
            backgroundImage = new Image();
            backgroundImage.onload = function() {
                backgroundImageLoaded = true;
                console.log('Background image loaded successfully');
            };
            backgroundImage.onerror = function() {
                console.warn('Failed to load background image');
                backgroundImageLoaded = false;
            };
            backgroundImage.src = 'assets/sprites/backgroundImage.jpg';
            
            // Load ghost sprite
            ghostImage = new Image();
            ghostImage.onload = function() {
                ghostImageLoaded = true;
                console.log('Ghost sprite loaded successfully');
            };
            ghostImage.onerror = function() {
                console.warn('Failed to load ghost sprite');
                ghostImageLoaded = false;
            };
            ghostImage.src = 'assets/sprites/ghost.png';
            
            // Initialize leaderboard
            loadLeaderboard();
            updateLeaderboardDisplay();
            
            // Initialize star field
            initStars();
            
            // Render legend icons
            renderLegendIcons();
            
            createLevel(level);
            resetBall();
            gameLoop();
        }
        
        // Create level with bricks
        function createLevel(levelNum) {
            bricks = [];
            const regularTypes = ['white', 'lightGray', 'darkGray', 'bloodRed'];
            const specialTypes = ['ghost', 'vampire'];
            
            for (let row = 0; row < BRICK_ROWS; row++) {
                bricks[row] = [];
                for (let col = 0; col < BRICK_COLS; col++) {
                    let type;
                    
                    // Determine brick type based on level and position
                    if (levelNum >= 1 && Math.random() < 0.15) {
                        // 15% chance for special bricks from level 1+
                        type = specialTypes[Math.floor(Math.random() * specialTypes.length)];
                    } else {
                        // Regular brick progression
                        const typeIndex = Math.min(row, regularTypes.length - 1);
                        type = regularTypes[typeIndex];
                    }
                    
                    const brick = {
                        x: col * (BRICK_WIDTH + BRICK_PADDING) + BRICK_OFFSET_LEFT,
                        y: row * (BRICK_HEIGHT + BRICK_PADDING) + BRICK_OFFSET_TOP,
                        width: BRICK_WIDTH,
                        height: BRICK_HEIGHT,
                        type: type,
                        hits: brickTypes[type].hits,
                        maxHits: brickTypes[type].hits,
                        visible: true
                    };
                    
                    // Add special properties for supernatural bricks
                    if (brickTypes[type].special === 'ghost') {
                        brick.phaseTimer = 0;
                        brick.isPhased = false;
                        brick.floatOffset = Math.random() * Math.PI * 2;
                    } else if (brickTypes[type].special === 'vampire') {
                        brick.regenerationTimer = 0;
                        brick.lastRegenTime = Date.now();
                    }
                    
                    bricks[row][col] = brick;
                }
            }
            
            playerMetrics.levelStartTime = Date.now();
        }
        
        // Create developer level with only 5 random bricks
        function createDeveloperLevel() {
            // First create a full level
            createLevel(1);
            
            // Get all brick positions
            const allBricks = [];
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    allBricks.push({ row, col });
                }
            }
            
            // Shuffle the array to randomize selection
            for (let i = allBricks.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allBricks[i], allBricks[j]] = [allBricks[j], allBricks[i]];
            }
            
            // Hide all bricks first
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    bricks[row][col].visible = false;
                }
            }
            
            // Show only the first 5 random bricks
            for (let i = 0; i < Math.min(5, allBricks.length); i++) {
                const { row, col } = allBricks[i];
                bricks[row][col].visible = true;
            }
            
            console.log('Developer mode activated: 5 random bricks remaining');
        }
        
        // Activate developer mode
        function activateDeveloperMode() {
            developerMode = true;
            lives = 3;
            score = 0;
            level = 1;
            gameState = 'waiting';
            
            // Reset metrics
            Object.keys(playerMetrics).forEach(key => {
                if (typeof playerMetrics[key] === 'number') {
                    playerMetrics[key] = 0;
                }
            });
            playerMetrics.levelStartTime = Date.now();
            
            // Reset power-ups
            powerUps.length = 0;
            activePowerUps.length = 0;
            
            // Reset paddle and ball
            paddle.width = paddle.originalWidth;
            ball.speed = ball.originalSpeed;
            
            // Hide game over screen if visible
            document.getElementById('gameOverScreen').style.display = 'none';
            
            // Create developer level with 5 random bricks
            createDeveloperLevel();
            resetBall();
            
            console.log('Developer mode activated - 5 bricks, 3 lives, no high score saving');
        }
        
        // Change developer level (+ and - keys)
        function changeDeveloperLevel(direction) {
            if (!developerMode) return;
            
            const newLevel = Math.max(1, level + direction);
            level = newLevel;
            
            // Create full level layout for the new level
            createLevel(level);
            resetBall();
            
            console.log(`Developer mode: Changed to level ${level}`);
        }
        
        // Adjust developer lives ([ and ] keys)
        function adjustDeveloperLives(change) {
            if (!developerMode) return;
            
            const newLives = Math.max(0, Math.min(10, lives + change));
            lives = newLives;
            
            // Check for game over if lives reach 0
            if (lives <= 0 && gameState !== 'gameOver') {
                gameOver();
            }
            
            console.log(`Developer mode: Lives adjusted to ${lives}`);
        }
        
        // Reset ball to paddle
        function resetBall() {
            ball.x = paddle.x + paddle.width / 2;
            ball.y = paddle.y - BALL_RADIUS - 1;
            ball.vx = 0;
            ball.vy = 0;
            ball.onPaddle = true;
            gameState = 'waiting';
        }
        
        // Launch ball
        function launchBall() {
            if (ball.onPaddle) {
                ball.onPaddle = false;
                ball.vx = (Math.random() - 0.5) * 4;
                ball.vy = -ball.speed;
                gameState = 'playing';
                
                // Start background music when gameplay begins
                soundManager.startBackgroundMusic();
            }
        }
        
        // Update paddle position
        function updatePaddle() {
            if (useMouseControl) {
                paddle.x = mouseX - paddle.width / 2;
            } else {
                if (keys.left && paddle.x > 0) {
                    paddle.x -= paddle.speed;
                }
                if (keys.right && paddle.x < CANVAS_WIDTH - paddle.width) {
                    paddle.x += paddle.speed;
                }
            }
            
            // Keep paddle in bounds
            paddle.x = Math.max(0, Math.min(CANVAS_WIDTH - paddle.width, paddle.x));
            
            // Move ball with paddle when on paddle
            if (ball.onPaddle) {
                ball.x = paddle.x + paddle.width / 2;
            }
        }
        
        // Update ball position and physics
        function updateBall() {
            if (ball.onPaddle) return;
            
            // Apply AI physics assistance
            applyPhysicsAssistance();
            
            ball.x += ball.vx;
            ball.y += ball.vy;
            
            // Wall collisions
            if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= CANVAS_WIDTH) {
                ball.vx = -ball.vx;
                ball.x = Math.max(ball.radius, Math.min(CANVAS_WIDTH - ball.radius, ball.x));
                playerMetrics.totalBallBounces++;
            }
            
            if (ball.y - ball.radius <= 0) {
                ball.vy = -ball.vy;
                ball.y = ball.radius;
                playerMetrics.totalBallBounces++;
            }
            
            // Ball fell off bottom
            if (ball.y - ball.radius > CANVAS_HEIGHT) {
                loseLife();
                return;
            }
            
            // Paddle collision
            checkPaddleBallCollision();
            
            // Brick collisions
            checkBrickCollisions();
        }
        
        // Check paddle-ball collision
        function checkPaddleBallCollision() {
            // First try AI assistance for struggling players
            if (applyCollisionAssistance()) {
                return; // AI assistance handled the collision
            }
            
            // Normal collision detection
            if (ball.y + ball.radius >= paddle.y &&
                ball.y - ball.radius <= paddle.y + paddle.height &&
                ball.x >= paddle.x &&
                ball.x <= paddle.x + paddle.width) {
                
                // Calculate hit position on paddle (-1 to 1)
                const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                
                // Adjust ball angle based on hit position
                ball.vx = hitPos * 5;
                ball.vy = -Math.abs(ball.vy);
                
                // Ensure minimum upward velocity
                if (Math.abs(ball.vy) < 3) {
                    ball.vy = -3;
                }
                
                ball.y = paddle.y - ball.radius;
                playerMetrics.paddleHits++;
                playerMetrics.totalBallBounces++;
            }
        }
        
        // Check brick collisions
        function checkBrickCollisions() {
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    if (!brick.visible) continue;
                    
                    // Skip ghost bricks when they're phased out
                    if (brickTypes[brick.type].special === 'ghost' && brick.isPhased) {
                        continue;
                    }
                    
                    if (ball.x + ball.radius >= brick.x &&
                        ball.x - ball.radius <= brick.x + brick.width &&
                        ball.y + ball.radius >= brick.y &&
                        ball.y - ball.radius <= brick.y + brick.height) {
                        
                        // Determine collision side
                        const overlapLeft = (ball.x + ball.radius) - brick.x;
                        const overlapRight = (brick.x + brick.width) - (ball.x - ball.radius);
                        const overlapTop = (ball.y + ball.radius) - brick.y;
                        const overlapBottom = (brick.y + brick.height) - (ball.y - ball.radius);
                        
                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                        
                        if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                            ball.vx = -ball.vx;
                        } else {
                            ball.vy = -ball.vy;
                        }
                        
                        // Damage brick
                        brick.hits--;
                        playerMetrics.bricksHit++;
                        
                        if (brick.hits <= 0) {
                            brick.visible = false;
                            score += brickTypes[brick.type].points;
                            
                            // Play glass shattering sound for brick break
                            soundManager.playBrickBreak();
                            
                            // Create particles
                            createParticles(brick.x + brick.width / 2, brick.y + brick.height / 2, brickTypes[brick.type].color);
                            
                            // Screen shake
                            addScreenShake(2, 100);
                            
                            // AI-enhanced power-up spawning
                            if (shouldSpawnHelpfulPowerUp()) {
                                spawnPowerUp(brick.x + brick.width / 2, brick.y + brick.height / 2);
                            }
                        } else {
                            // Play dull thump sound for brick hit (not destroyed)
                            soundManager.playBrickHit();
                        }
                        
                        // Check if level complete
                        if (isLevelComplete()) {
                            level++;
                            lives = 3; // Reset lives to 3 each level
                            createLevel(level);
                            resetBall();
                        }
                        
                        return; // Only hit one brick per frame
                    }
                }
            }
        }
        
        // Check if level is complete
        function isLevelComplete() {
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    if (bricks[row][col].visible) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        // Lose a life
        function loseLife() {
            lives--;
            playerMetrics.ballsLost++;
            playerMetrics.paddleMisses++;
            
            // Play high pitch violin screech for life lost
            soundManager.playLifeLost();
            
            const now = Date.now();
            if (now - playerMetrics.lastBallLoss < 5000) {
                playerMetrics.consecutiveDeaths++;
            } else {
                playerMetrics.consecutiveDeaths = 1;
            }
            playerMetrics.lastBallLoss = now;
            
            // Check if level is complete before checking game over
            // This allows finishing the level even with 0 lives
            if (isLevelComplete()) {
                level++;
                createLevel(level);
                resetBall();
                return; // Don't check for game over if level is complete
            }
            
            if (lives <= 0) {
                gameOver();
            } else {
                resetBall();
            }
        }
        
        // Game over
        function gameOver() {
            gameState = 'gameOver';
            
            // Stop background music and play dramatic end game sound
            soundManager.stopBackgroundMusic();
            soundManager.playEndGameSound();
            
            // Check if this is a high score (but not in developer mode)
            isNewHighScore = !developerMode && isHighScore(score);
            
            document.getElementById('finalScore').textContent = score;
            
            if (isNewHighScore) {
                showNameEntry();
            } else {
                showDeveloperGameOverScreen();
            }
        }
        
        // Show game over screen with developer mode message if applicable
        function showDeveloperGameOverScreen() {
            const gameOverScreen = document.getElementById('gameOverScreen');
            
            if (developerMode) {
                gameOverScreen.innerHTML = `
                    <h2>Game Over!</h2>
                    <div>Final Score: <span id="finalScore">${score}</span></div>
                    <div style="color: #ffaa00; margin: 15px 0; font-size: 14px;">
                        DEVELOPER MODE - NO SCORE SAVED
                    </div>
                    <button onclick="restartGame()">Play Again</button>
                `;
            } else {
                gameOverScreen.innerHTML = `
                    <h2>Game Over!</h2>
                    <div>Final Score: <span id="finalScore">${score}</span></div>
                    <button onclick="restartGame()">Play Again</button>
                `;
            }
            
            gameOverScreen.style.display = 'block';
        }
        
        // Show name entry for high score
        function showNameEntry() {
            const gameOverScreen = document.getElementById('gameOverScreen');
            
            // Create name entry HTML
            gameOverScreen.innerHTML = `
                <h2>NEW HIGH SCORE!</h2>
                <div>Final Score: <span id="finalScore">${score}</span></div>
                <div class="name-entry">
                    <div style="margin-bottom: 10px;">Enter your name (3 characters):</div>
                    <input type="text" id="playerNameInput" maxlength="3" placeholder="ABC" 
                           style="text-transform: uppercase;" autocomplete="off">
                </div>
                <button onclick="submitHighScore()" id="submitButton">Submit Score</button>
                <button onclick="skipHighScore()">Skip</button>
            `;
            
            gameOverScreen.style.display = 'block';
            
            // Focus on input and add event listeners
            const nameInput = document.getElementById('playerNameInput');
            nameInput.focus();
            
            // Handle input validation
            nameInput.addEventListener('input', function(e) {
                let value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
                e.target.value = value;
                
                // Enable/disable submit button
                const submitButton = document.getElementById('submitButton');
                submitButton.disabled = value.length === 0;
            });
            
            // Handle Enter key
            nameInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && e.target.value.length > 0) {
                    submitHighScore();
                }
            });
        }
        
        // Submit high score
        function submitHighScore() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim();
            
            if (name.length > 0) {
                addToLeaderboard(name, score);
                showGameOverScreen();
            }
        }
        
        // Skip high score entry
        function skipHighScore() {
            showGameOverScreen();
        }
        
        // Show regular game over screen
        function showGameOverScreen() {
            const gameOverScreen = document.getElementById('gameOverScreen');
            
            gameOverScreen.innerHTML = `
                <h2>Game Over!</h2>
                <div>Final Score: <span id="finalScore">${score}</span></div>
                <button onclick="restartGame()">Play Again</button>
            `;
            
            isNewHighScore = false;
            playerName = '';
        }
        
        // Restart game
        function restartGame() {
            lives = 3;
            score = 0;
            level = 1;
            gameState = 'waiting';
            developerMode = false; // Reset developer mode
            
            // Reset metrics
            Object.keys(playerMetrics).forEach(key => {
                if (typeof playerMetrics[key] === 'number') {
                    playerMetrics[key] = 0;
                }
            });
            playerMetrics.levelStartTime = Date.now();
            
            // Reset power-ups
            powerUps.length = 0;
            activePowerUps.length = 0;
            
            // Reset paddle and ball
            paddle.width = paddle.originalWidth;
            ball.speed = ball.originalSpeed;
            
            document.getElementById('gameOverScreen').style.display = 'none';
            createLevel(level);
            resetBall();
        }
        
        // Spawn power-up
        function spawnPowerUp(x, y) {
            const types = Object.keys(powerUpTypes);
            const type = types[Math.floor(Math.random() * types.length)];
            
            powerUps.push({
                x: x,
                y: y,
                type: type,
                width: 30,
                height: 15,
                speed: 2
            });
        }
        
        // Update power-ups
        function updatePowerUps() {
            // Update falling power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.speed;
                
                // Check collision with paddle
                if (powerUp.y + powerUp.height >= paddle.y &&
                    powerUp.y <= paddle.y + paddle.height &&
                    powerUp.x + powerUp.width >= paddle.x &&
                    powerUp.x <= paddle.x + paddle.width) {
                    
                    collectPowerUp(powerUp);
                    powerUps.splice(i, 1);
                    continue;
                }
                
                // Remove if off screen
                if (powerUp.y > CANVAS_HEIGHT) {
                    powerUps.splice(i, 1);
                }
            }
            
            // Update active power-ups
            const now = Date.now();
            for (let i = activePowerUps.length - 1; i >= 0; i--) {
                const powerUp = activePowerUps[i];
                if (now >= powerUp.endTime) {
                    removePowerUpEffect(powerUp.type);
                    activePowerUps.splice(i, 1);
                }
            }
        }
        
        // Collect power-up
        function collectPowerUp(powerUp) {
            applyPowerUpEffect(powerUp.type);
            addScreenShake(3, 150);
        }
        
        // Apply power-up effect
        function applyPowerUpEffect(type) {
            const now = Date.now();
            const duration = powerUpTypes[type].duration;
            
            // Remove existing effect of same type
            for (let i = activePowerUps.length - 1; i >= 0; i--) {
                if (activePowerUps[i].type === type) {
                    activePowerUps.splice(i, 1);
                }
            }
            
            // Add new effect
            activePowerUps.push({
                type: type,
                endTime: now + duration
            });
            
            // Apply immediate effects
            switch(type) {
                case 'widePaddle':
                    paddle.width = paddle.originalWidth * 1.5;
                    break;
                case 'slowBall':
                    ball.speed = ball.originalSpeed * 0.7;
                    // Adjust current velocity
                    const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    if (currentSpeed > 0) {
                        const ratio = ball.speed / currentSpeed;
                        ball.vx *= ratio;
                        ball.vy *= ratio;
                    }
                    break;
            }
        }
        
        // Remove power-up effect
        function removePowerUpEffect(type) {
            switch(type) {
                case 'widePaddle':
                    paddle.width = paddle.originalWidth;
                    break;
                case 'slowBall':
                    ball.speed = ball.originalSpeed;
                    // Adjust current velocity
                    const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    if (currentSpeed > 0) {
                        const ratio = ball.speed / currentSpeed;
                        ball.vx *= ratio;
                        ball.vy *= ratio;
                    }
                    break;
            }
        }
        
        // Create particles
        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 1.0,
                    decay: 0.02,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        // Create explosion particles
        function createExplosionParticles(x, y) {
            for (let i = 0; i < 25; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    decay: 0.015,
                    color: ['#ff4444', '#ff8800', '#ffaa00', '#cc0000'][Math.floor(Math.random() * 4)],
                    size: Math.random() * 6 + 3
                });
            }
        }
        
        // Explode ball function
        function explodeBall() {
            const explosionRadius = 180;
            let bricksDestroyed = 0;
            
            // Play explosion sound
            soundManager.playExplosion();
            
            // Create massive explosion particles
            createExplosionParticles(ball.x, ball.y);
            
            // Add intense screen shake
            addScreenShake(8, 400);
            
            // Check all bricks for destruction within explosion radius
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    if (!brick.visible) continue;
                    
                    // Calculate distance from explosion center to brick center
                    const brickCenterX = brick.x + brick.width / 2;
                    const brickCenterY = brick.y + brick.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(ball.x - brickCenterX, 2) + 
                        Math.pow(ball.y - brickCenterY, 2)
                    );
                    
                    // Destroy brick if within explosion radius
                    if (distance <= explosionRadius) {
                        brick.visible = false;
                        score += brickTypes[brick.type].points;
                        bricksDestroyed++;
                        
                        // Create particles for each destroyed brick
                        createParticles(brickCenterX, brickCenterY, brickTypes[brick.type].color);
                    }
                }
            }
            
            // Update player metrics
            playerMetrics.bricksHit += bricksDestroyed;
            
            // Check if level is complete before losing life
            if (isLevelComplete()) {
                level++;
                createLevel(level);
                resetBall();
                return; // Don't lose a life if level is complete
            }
            
            // Lose a life (ball is destroyed in explosion)
            loseLife();
        }
        
        // Create ball trail sparkles
        function createBallTrail() {
            if (ball.onPaddle) return;
            
            // Create sparkle particles at ball position
            const colors = ['#ffffff', '#ffdd00', '#88ccff', '#cc88ff'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            ballTrailParticles.push({
                x: ball.x + (Math.random() - 0.5) * 4,
                y: ball.y + (Math.random() - 0.5) * 4,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                life: 1.0,
                decay: 0.03,
                color: color,
                size: Math.random() * 2 + 1,
                twinkle: Math.random() * Math.PI * 2,
                twinkleSpeed: Math.random() * 0.1 + 0.05
            });
            
            // Limit trail particles to prevent performance issues
            if (ballTrailParticles.length > 50) {
                ballTrailParticles.splice(0, ballTrailParticles.length - 50);
            }
        }
        
        // Update ball trail particles
        function updateBallTrail() {
            for (let i = ballTrailParticles.length - 1; i >= 0; i--) {
                const particle = ballTrailParticles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;
                particle.size *= 0.99;
                particle.twinkle += particle.twinkleSpeed;
                
                // Add slight gravity
                particle.vy += 0.02;
                
                if (particle.life <= 0) {
                    ballTrailParticles.splice(i, 1);
                }
            }
        }
        
        // Update special bricks
        function updateSpecialBricks() {
            const now = Date.now();
            
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    if (!brick.visible) continue;
                    
                    // Update ghost bricks
                    if (brickTypes[brick.type].special === 'ghost') {
                        brick.phaseTimer += 16; // Assuming 60fps
                        brick.floatOffset += 0.02;
                        
                        // Phase cycle: 3 seconds visible, 2 seconds invisible
                        const cycleTime = 5000; // 5 seconds total
                        const visibleTime = 3000; // 3 seconds visible
                        
                        const cyclePosition = brick.phaseTimer % cycleTime;
                        brick.isPhased = cyclePosition > visibleTime;
                    }
                    
                    // Update vampire bricks
                    else if (brickTypes[brick.type].special === 'vampire') {
                        brick.regenerationTimer += 16;
                        
                        // Regenerate 1 hit point every 8 seconds if not at max health
                        if (brick.regenerationTimer >= 8000 && brick.hits < brick.maxHits) {
                            brick.hits++;
                            brick.regenerationTimer = 0;
                            
                            // Create blood drip particles
                            createVampireRegenParticles(brick.x + brick.width / 2, brick.y + brick.height);
                        }
                    }
                }
            }
        }
        
        // Create vampire regeneration particles
        function createVampireRegenParticles(x, y) {
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 2 + 1,
                    life: 1.0,
                    decay: 0.025,
                    color: '#cc0000',
                    size: Math.random() * 3 + 2
                });
            }
        }
        
        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;
                particle.size *= 0.98;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        // Add screen shake
        function addScreenShake(intensity, duration) {
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
            screenShake.duration = Math.max(screenShake.duration, duration);
        }
        
        // Update screen shake
        function updateScreenShake() {
            if (screenShake.duration > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.duration -= 16; // Assuming 60fps
                screenShake.intensity *= 0.9;
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
                screenShake.intensity = 0;
            }
        }
        
        // Floating Ghost System Functions
        function spawnFloatingGhost() {
            if (!ghostImageLoaded || floatingGhosts.length >= MAX_GHOSTS) return;
            
            const now = Date.now();
            if (now - lastGhostSpawn < GHOST_SPAWN_INTERVAL) return;
            
            // Get full page dimensions
            const pageWidth = window.innerWidth;
            const pageHeight = window.innerHeight;
            
            // Spawn ghost at random edge of full page
            const spawnSide = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
            let x, y, vx, vy;
            
            switch(spawnSide) {
                case 0: // Top
                    x = Math.random() * pageWidth;
                    y = -50;
                    vx = (Math.random() - 0.5) * 2;
                    vy = Math.random() * 1 + 0.5;
                    break;
                case 1: // Right
                    x = pageWidth + 50;
                    y = Math.random() * pageHeight;
                    vx = -(Math.random() * 1 + 0.5);
                    vy = (Math.random() - 0.5) * 2;
                    break;
                case 2: // Bottom
                    x = Math.random() * pageWidth;
                    y = pageHeight + 50;
                    vx = (Math.random() - 0.5) * 2;
                    vy = -(Math.random() * 1 + 0.5);
                    break;
                case 3: // Left
                    x = -50;
                    y = Math.random() * pageHeight;
                    vx = Math.random() * 1 + 0.5;
                    vy = (Math.random() - 0.5) * 2;
                    break;
            }
            
            floatingGhosts.push({
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                size: Math.random() * 60 + 80, // 80-140 pixels
                opacity: Math.random() * 0.4 + 0.3, // 0.3-0.7 opacity
                floatPhase: Math.random() * Math.PI * 2,
                floatSpeed: Math.random() * 0.02 + 0.01,
                lifetime: 0,
                maxLifetime: Math.random() * 20000 + 15000, // 15-35 seconds
                pageX: x, // Track page coordinates
                pageY: y
            });
            
            lastGhostSpawn = now;
        }
        
        function updateFloatingGhosts() {
            const now = Date.now();
            const pageWidth = window.innerWidth;
            const pageHeight = window.innerHeight;
            
            // Update existing ghosts
            for (let i = floatingGhosts.length - 1; i >= 0; i--) {
                const ghost = floatingGhosts[i];
                
                // Update position
                ghost.x += ghost.vx;
                ghost.y += ghost.vy;
                
                // Update floating animation
                ghost.floatPhase += ghost.floatSpeed;
                ghost.lifetime += 16; // Assuming 60fps
                
                // Add some random drift to movement
                ghost.vx += (Math.random() - 0.5) * 0.1;
                ghost.vy += (Math.random() - 0.5) * 0.1;
                
                // Limit velocity
                const maxSpeed = 2;
                const speed = Math.sqrt(ghost.vx * ghost.vx + ghost.vy * ghost.vy);
                if (speed > maxSpeed) {
                    ghost.vx = (ghost.vx / speed) * maxSpeed;
                    ghost.vy = (ghost.vy / speed) * maxSpeed;
                }
                
                // Remove ghost if it's been alive too long or moved too far off full page
                if (ghost.lifetime > ghost.maxLifetime || 
                    ghost.x < -200 || ghost.x > pageWidth + 200 ||
                    ghost.y < -200 || ghost.y > pageHeight + 200) {
                    floatingGhosts.splice(i, 1);
                }
            }
            
            // Spawn new ghosts
            spawnFloatingGhost();
            
            // Play ghost sound randomly
            if (now - lastGhostSound > GHOST_SOUND_INTERVAL) {
                // Add some randomness to the interval (25-35 seconds)
                const randomInterval = GHOST_SOUND_INTERVAL + Math.random() * 10000;
                if (now - lastGhostSound > randomInterval) {
                    soundManager.playGhostSound();
                    lastGhostSound = now;
                }
            }
        }
        
        function drawFloatingGhosts() {
            if (!ghostImageLoaded || !ghostImage) return;
            
            floatingGhosts.forEach(ghost => {
                // Create or update ghost DOM element for full page coverage
                let ghostElement = document.getElementById(`ghost-${floatingGhosts.indexOf(ghost)}`);
                
                if (!ghostElement) {
                    ghostElement = document.createElement('div');
                    ghostElement.id = `ghost-${floatingGhosts.indexOf(ghost)}`;
                    ghostElement.style.position = 'fixed';
                    ghostElement.style.pointerEvents = 'none';
                    ghostElement.style.zIndex = '10';
                    ghostElement.style.backgroundImage = `url('assets/sprites/ghost.png')`;
                    ghostElement.style.backgroundSize = 'contain';
                    ghostElement.style.backgroundRepeat = 'no-repeat';
                    ghostElement.style.filter = 'drop-shadow(0 0 15px #88ccff)';
                    document.body.appendChild(ghostElement);
                }
                
                // Calculate position with floating animation
                const floatOffset = Math.sin(ghost.floatPhase) * 5;
                const drawX = ghost.x;
                const drawY = ghost.y + floatOffset;
                
                // Calculate rotation based on movement direction
                const angle = Math.atan2(ghost.vy, ghost.vx);
                const rotation = (angle * 180 / Math.PI) + 90; // +90 to align head with direction
                
                // Determine opacity based on game area overlap
                let opacity = ghost.opacity;
                const canvas = document.getElementById('gameCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                const gameAreaLeft = canvasRect.left + BRICK_OFFSET_LEFT - 20;
                const gameAreaRight = canvasRect.left + BRICK_OFFSET_LEFT + (BRICK_COLS * (BRICK_WIDTH + BRICK_PADDING)) + 20;
                const gameAreaTop = canvasRect.top + BRICK_OFFSET_TOP - 20;
                const gameAreaBottom = canvasRect.top + paddle.y + paddle.height + 20;
                
                // If ghost overlaps with game area, reduce opacity significantly
                if (drawX + ghost.size > gameAreaLeft && drawX < gameAreaRight &&
                    drawY + ghost.size > gameAreaTop && drawY < gameAreaBottom) {
                    opacity *= 0.3; // Much more transparent when behind game
                }
                
                // Update ghost element styles
                ghostElement.style.left = `${drawX}px`;
                ghostElement.style.top = `${drawY}px`;
                ghostElement.style.width = `${ghost.size}px`;
                ghostElement.style.height = `${ghost.size}px`;
                ghostElement.style.opacity = opacity;
                ghostElement.style.transform = `rotate(${rotation}deg)`;
            });
            
            // Clean up removed ghosts
            const existingGhosts = document.querySelectorAll('[id^="ghost-"]');
            existingGhosts.forEach(element => {
                const index = parseInt(element.id.split('-')[1]);
                if (index >= floatingGhosts.length) {
                    element.remove();
                }
            });
        }
        
        // Handle input
        function handleInput() {
            if (keys.space && gameState === 'waiting') {
                launchBall();
            }
        }
        
        // Update game
        function update() {
            handleInput();
            updatePaddle();
            updateBall();
            updatePowerUps();
            updateParticles();
            updateBallTrail();
            updateSpecialBricks();
            updateScreenShake();
            updateStars();
            updateFloatingGhosts();
            updateUI();
            
            // Create ball trail sparkles
            createBallTrail();
        }
        
        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('level').textContent = level;
            
            // Update power-up timers
            const timersDiv = document.getElementById('powerUpTimers');
            timersDiv.innerHTML = '';
            
            const now = Date.now();
            activePowerUps.forEach(powerUp => {
                const timeLeft = Math.max(0, powerUp.endTime - now);
                const seconds = Math.ceil(timeLeft / 1000);
                
                const timerDiv = document.createElement('div');
                timerDiv.className = 'power-up-timer';
                timerDiv.textContent = `${powerUpTypes[powerUp.type].name}: ${seconds}s`;
                timerDiv.style.borderColor = powerUpTypes[powerUp.type].color;
                timersDiv.appendChild(timerDiv);
            });
        }
        
        // Render game
        function render() {
            // Clear canvas with screen shake
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);
            
            // Draw background image if loaded, otherwise use black background
            if (backgroundImageLoaded && backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            } else {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }
            
            // If game over, show spooky face image instead of normal game
            if (gameState === 'gameOver' && imageLoaded && gameOverImage) {
                // Draw the face image to fill the entire canvas
                ctx.drawImage(gameOverImage, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.restore();
                return; // Don't draw normal game elements
            }
            
            // Draw stars on top of background
            drawStars();
            
            // Draw floating ghosts (behind game elements but above background)
            drawFloatingGhosts();
            
            // Draw ball trail sparkles first (behind everything else)
            ballTrailParticles.forEach(particle => {
                const twinkleAlpha = particle.life * (0.5 + 0.5 * Math.sin(particle.twinkle));
                ctx.globalAlpha = twinkleAlpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw bricks
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    if (!brick.visible) continue;
                    
                    let alpha = brick.hits / brick.maxHits;
                    const color = brickTypes[brick.type].color;
                    let brickY = brick.y;
                    
                    // Special rendering for ghost bricks
                    if (brickTypes[brick.type].special === 'ghost') {
                        // Floating animation
                        brickY += Math.sin(brick.floatOffset) * 3;
                        
                        // Phase in/out effect
                        if (brick.isPhased) {
                            alpha *= 0.2; // Very transparent when phased
                        } else {
                            alpha *= 0.7; // Semi-transparent when visible
                        }
                        
                        // Add ethereal glow
                        ctx.shadowColor = color;
                        ctx.shadowBlur = 15;
                    }
                    
                    // Special rendering for vampire bricks
                    else if (brickTypes[brick.type].special === 'vampire') {
                        // Pulsing effect when regenerating
                        if (brick.regenerationTimer > 7000) { // Last second before regen
                            const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                            alpha *= pulse;
                            
                            // Add red glow when regenerating
                            ctx.shadowColor = '#cc0000';
                            ctx.shadowBlur = 10;
                        }
                    }
                    
                    ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.fillRect(brick.x, brickY, brick.width, brick.height);
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    
                    // Add border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(brick.x, brickY, brick.width, brick.height);
                }
            }
            
            // Draw paddle
            ctx.fillStyle = '#000000';
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            // Add white border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            // Draw ball (hollow with white border)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Add ball glow
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw power-ups with unique styles
            powerUps.forEach(powerUp => {
                const centerX = powerUp.x + powerUp.width / 2;
                const centerY = powerUp.y + powerUp.height / 2;
                
                ctx.shadowColor = powerUpTypes[powerUp.type].color;
                ctx.shadowBlur = 10;
                
                if (powerUp.type === 'widePaddle') {
                    // Wide paddle: Draw as wider rectangle with paddle-like appearance
                    ctx.fillStyle = powerUpTypes[powerUp.type].color;
                    ctx.fillRect(powerUp.x - 5, powerUp.y, powerUp.width + 10, powerUp.height);
                    
                    // Add white border to look like paddle
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(powerUp.x - 5, powerUp.y, powerUp.width + 10, powerUp.height);
                    
                } else if (powerUp.type === 'slowBall') {
                    // Slow ball: Draw as circle with clock markings
                    const radius = Math.max(powerUp.width, powerUp.height) / 2;
                    
                    // Draw circle
                    ctx.fillStyle = powerUpTypes[powerUp.type].color;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add white border
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Add clock markings
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    // Top mark
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - radius + 2);
                    ctx.lineTo(centerX, centerY - radius + 6);
                    ctx.stroke();
                    // Bottom mark
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + radius - 2);
                    ctx.lineTo(centerX, centerY + radius - 6);
                    ctx.stroke();
                    // Left mark
                    ctx.beginPath();
                    ctx.moveTo(centerX - radius + 2, centerY);
                    ctx.lineTo(centerX - radius + 6, centerY);
                    ctx.stroke();
                    // Right mark
                    ctx.beginPath();
                    ctx.moveTo(centerX + radius - 2, centerY);
                    ctx.lineTo(centerX + radius - 6, centerY);
                    ctx.stroke();
                }
                
                ctx.shadowBlur = 0;
            });
            
            // Draw particles
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw waiting message
            if (gameState === 'waiting') {
                ctx.fillStyle = '#ffff00';
                ctx.font = '26px ScaryFont, Courier New, monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Press SPACE to launch ball', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            }
            
            ctx.restore();
        }
        
        // Game loop
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (gameState !== 'gameOver') {
                update();
            }
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Toggle sound function (global for button onclick)
        function toggleSound() {
            const enabled = soundManager.toggleSound();
            const button = document.getElementById('soundToggle');
            button.textContent = enabled ? '🔊 Sound: ON' : '🔇 Sound: OFF';
        }
        
        // Start the game
        init();
    </script>
</body>
</html>
