<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spooky Breakout - AI-Enhanced Brick Ball Game</title>
    <style>
        @font-face {
            font-family: 'ScaryFont';
            src: url('assets/font/scaryfont.ttf') format('truetype');
            font-display: swap;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background: #000000;
            color: #ffffff;
            font-family: 'ScaryFont', 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameCanvas {
            border: 2px solid #cc0000;
            background: #000;
            box-shadow: 0 0 20px rgba(204, 0, 0, 0.5);
        }
        
        .ui {
            margin: 10px 0;
            font-size: 18px;
            text-align: center;
        }
        
        .game-info {
            display: flex;
            gap: 30px;
            margin-bottom: 10px;
        }
        
        .power-up-timer {
            background: rgba(204, 0, 0, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            margin: 5px;
            border: 1px solid #cc0000;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
        }
        
        .leaderboard {
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #cc0000;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(204, 0, 0, 0.3);
        }
        
        .leaderboard h3 {
            margin: 0 0 15px 0;
            color: #cc0000;
            text-align: center;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(204, 0, 0, 0.8);
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            font-size: 14px;
        }
        
        .leaderboard-entry:last-child {
            border-bottom: none;
        }
        
        .leaderboard-rank {
            color: #888;
            width: 25px;
        }
        
        .leaderboard-name {
            color: #fff;
            flex: 1;
            text-align: center;
        }
        
        .leaderboard-score {
            color: #cc0000;
            font-weight: bold;
        }
        
        .leaderboard-entry.empty .leaderboard-name,
        .leaderboard-entry.empty .leaderboard-score {
            color: #444;
        }
        
        .reset-button {
            width: 100%;
            margin: 15px 0 5px 0;
            padding: 8px 15px;
            background: #222;
            color: #cc0000;
            border: 2px solid #cc0000;
            font-size: 14px;
        }
        
        .reset-button:hover {
            background: #333;
            border-color: #ff4444;
            color: #ff4444;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #ff4444;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        
        .name-entry {
            margin: 20px 0;
        }
        
        .name-entry input {
            background: #333;
            color: #fff;
            border: 2px solid #cc0000;
            padding: 10px;
            font-family: inherit;
            font-size: 18px;
            text-align: center;
            text-transform: uppercase;
            max-width: 80px;
            letter-spacing: 2px;
        }
        
        .name-entry input:focus {
            outline: none;
            border-color: #ff4444;
            box-shadow: 0 0 10px rgba(204, 0, 0, 0.5);
        }
        
        button {
            background: #333;
            color: #fff;
            border: 2px solid #666;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 16px;
        }
        
        button:hover {
            background: #555;
            border-color: #888;
        }
        
        button:disabled {
            background: #222;
            color: #666;
            border-color: #444;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>Spooky Breakout</h1>
    <div class="ui">
        <div class="game-info">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Level: <span id="level">1</span></div>
            <div>Version: <span id="version">1.0.0</span></div>
        </div>
    </div>
    
    <div class="game-container">
        <div class="leaderboard">
            <h3>HIGH SCORES</h3>
            <div id="leaderboardList">
                <!-- Leaderboard entries will be populated here -->
            </div>
            <div id="powerUpTimers"></div>
            <button onclick="resetLeaderboard()" class="reset-button">Reset Scores</button>
            
            <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #333; font-size: 12px; line-height: 1.4;">
                <div style="margin-bottom: 8px;">‚Ä¢ Use ‚Üê ‚Üí arrow keys or mouse to control paddle</div>
                <div style="margin-bottom: 8px;">‚Ä¢ Press SPACE to launch ball</div>
                <div style="margin-bottom: 8px;">‚Ä¢ Press B to explode ball (costs a life!)</div>
                <div style="margin-bottom: 8px;">‚Ä¢ Press M to toggle sound</div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>
    
    <div class="ui">
        <button id="soundToggle" onclick="toggleSound()">üîä Sound: ON</button>
    </div>
    
    <div id="gameOverScreen" class="game-over">
        <h2>Game Over!</h2>
        <div>Final Score: <span id="finalScore">0</span></div>
        <button onclick="restartGame()">Play Again</button>
    </div>

    <!-- Audio Elements -->
    <audio id="backgroundMusic" preload="auto" loop>
        <source src="assets/audio/background.mp3" type="audio/mpeg">
    </audio>
    <audio id="endGameSound" preload="auto">
        <source src="assets/audio/endgame.mp3" type="audio/mpeg">
    </audio>
    <audio id="explosionSound" preload="auto">
        <source src="assets/audio/explosion.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Version tracking
        const GAME_VERSION = '1.7.0';
        
        // Game canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const PADDLE_WIDTH = 100;
        const PADDLE_HEIGHT = 15;
        const BALL_RADIUS = 8;
        const BRICK_WIDTH = 75;
        const BRICK_HEIGHT = 20;
        const BRICK_ROWS = 6;
        const BRICK_COLS = 9;
        const BRICK_PADDING = 5;
        const BRICK_OFFSET_TOP = 60;
        const BRICK_OFFSET_LEFT = 35;
        
        // Game state
        let gameState = 'waiting'; // 'waiting', 'playing', 'gameOver'
        let lives = 3;
        let score = 0;
        let level = 1;
        let lastTime = 0;
        
        // Input handling
        const keys = {
            left: false,
            right: false,
            space: false
        };
        
        let mouseX = CANVAS_WIDTH / 2;
        let useMouseControl = false;
        
        // Game objects
        const paddle = {
            x: CANVAS_WIDTH / 2 - PADDLE_WIDTH / 2,
            y: CANVAS_HEIGHT - 30,
            width: PADDLE_WIDTH,
            height: PADDLE_HEIGHT,
            speed: 7,
            originalWidth: PADDLE_WIDTH
        };
        
        const ball = {
            x: CANVAS_WIDTH / 2,
            y: paddle.y - BALL_RADIUS - 1,
            vx: 0,
            vy: 0,
            radius: BALL_RADIUS,
            speed: 5,
            originalSpeed: 5,
            onPaddle: true
        };
        
        // Brick types - Spooky theme: white to red gradient
        const brickTypes = {
            white: { hits: 1, points: 10, color: '#ffffff' },
            lightGray: { hits: 1, points: 20, color: '#cccccc' },
            darkGray: { hits: 2, points: 30, color: '#666666' },
            bloodRed: { hits: 2, points: 40, color: '#cc0000' }
        };
        
        // Bricks array
        let bricks = [];
        
        // Power-ups
        const powerUps = [];
        const activePowerUps = [];
        
        const powerUpTypes = {
            widePaddle: { 
                duration: 15000, 
                color: '#cc0000',
                name: 'Wide Paddle'
            },
            slowBall: { 
                duration: 20000, 
                color: '#ff4444',
                name: 'Slow Ball'
            }
        };
        
        // AI Performance Tracking
        const playerMetrics = {
            ballsLost: 0,
            bricksHit: 0,
            totalBallBounces: 0,
            paddleHits: 0,
            paddleMisses: 0,
            timeSpentOnLevel: 0,
            consecutiveDeaths: 0,
            levelStartTime: Date.now(),
            lastBallLoss: 0,
            recentPerformance: [] // Track recent performance windows
        };
        
        // AI Assistance System
        function calculateAccuracy() {
            const totalAttempts = playerMetrics.paddleHits + playerMetrics.paddleMisses;
            if (totalAttempts === 0) return 1.0;
            return playerMetrics.paddleHits / totalAttempts;
        }
        
        function getStruggleLevel() {
            const accuracy = calculateAccuracy();
            const timeSinceStart = Date.now() - playerMetrics.levelStartTime;
            const avgTimePerBrick = timeSinceStart / Math.max(1, playerMetrics.bricksHit);
            
            // High struggle indicators
            if (playerMetrics.consecutiveDeaths >= 3 || accuracy < 0.3) return 2;
            
            // Medium struggle indicators  
            if (playerMetrics.consecutiveDeaths >= 2 || accuracy < 0.6 || avgTimePerBrick > 10000) return 1;
            
            // No struggle
            return 0;
        }
        
        function getAssistanceLevel() {
            return getStruggleLevel();
        }
        
        function shouldSpawnHelpfulPowerUp() {
            const struggleLevel = getStruggleLevel();
            const baseChance = 0.1;
            
            // Increase power-up chance based on struggle
            switch(struggleLevel) {
                case 2: return Math.random() < baseChance * 3; // 30% chance
                case 1: return Math.random() < baseChance * 2; // 20% chance
                default: return Math.random() < baseChance;    // 10% chance
            }
        }
        
        function applyPhysicsAssistance() {
            const assistanceLevel = getAssistanceLevel();
            
            if (assistanceLevel === 0) return; // No help needed
            
            // Subtle paddle magnetism for struggling players
            if (assistanceLevel >= 1 && !ball.onPaddle) {
                const paddleCenter = paddle.x + paddle.width / 2;
                const ballToPaddle = paddleCenter - ball.x;
                const distance = Math.abs(ballToPaddle);
                
                // Only apply if ball is reasonably close and moving toward paddle
                if (distance < 100 && ball.vy > 0 && ball.y > paddle.y - 100) {
                    const magnetStrength = assistanceLevel === 2 ? 0.3 : 0.15;
                    ball.vx += (ballToPaddle > 0 ? magnetStrength : -magnetStrength);
                }
            }
        }
        
        function applyCollisionAssistance() {
            const assistanceLevel = getAssistanceLevel();
            
            if (assistanceLevel === 0) return false; // No help
            
            // Expand collision detection for struggling players
            const expansion = assistanceLevel === 2 ? 8 : 4;
            
            // Check expanded paddle collision
            if (ball.y + ball.radius >= paddle.y - expansion &&
                ball.y - ball.radius <= paddle.y + paddle.height + expansion &&
                ball.x + ball.radius >= paddle.x - expansion &&
                ball.x - ball.radius <= paddle.x + paddle.width + expansion) {
                
                // Only help if ball would have missed normally
                if (!(ball.y + ball.radius >= paddle.y &&
                      ball.y - ball.radius <= paddle.y + paddle.height &&
                      ball.x >= paddle.x &&
                      ball.x <= paddle.x + paddle.width)) {
                    
                    // Apply helpful bounce
                    const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                    ball.vx = hitPos * 4;
                    ball.vy = -Math.abs(ball.vy);
                    
                    if (Math.abs(ball.vy) < 3) {
                        ball.vy = -3;
                    }
                    
                    ball.y = paddle.y - ball.radius;
                    playerMetrics.paddleHits++;
                    playerMetrics.totalBallBounces++;
                    
                    return true; // Assistance was applied
                }
            }
            
            return false;
        }
        
        // Particles for visual effects
        const particles = [];
        
        // Screen shake
        let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
        
        // Sound System
        let audioContext = null;
        let soundEnabled = true;
        let backgroundMusic = null;
        let endGameSound = null;
        let explosionSound = null;
        let musicStarted = false;
        
        // Game over image
        let gameOverImage = null;
        let imageLoaded = false;
        
        // Leaderboard System
        const LEADERBOARD_KEY = 'spookyBreakoutLeaderboard';
        const OLD_LEADERBOARD_KEY = 'adaptiveBreakoutLeaderboard';
        const MAX_LEADERBOARD_ENTRIES = 10;
        let leaderboard = [];
        let isNewHighScore = false;
        let playerName = '';
        
        const soundManager = {
            init() {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    soundEnabled = false;
                }
                
                // Initialize HTML5 audio elements
                backgroundMusic = document.getElementById('backgroundMusic');
                endGameSound = document.getElementById('endGameSound');
                explosionSound = document.getElementById('explosionSound');
                
                // Set volume levels
                if (backgroundMusic) {
                    backgroundMusic.volume = 0.3; // Lower volume for ambiance
                }
                if (endGameSound) {
                    endGameSound.volume = 0.7; // Higher volume for dramatic effect
                }
                if (explosionSound) {
                    explosionSound.volume = 0.8; // High volume for explosion impact
                }
            },
            
            startBackgroundMusic() {
                if (!soundEnabled || !backgroundMusic || musicStarted) return;
                
                try {
                    backgroundMusic.currentTime = 0;
                    backgroundMusic.play().catch(e => {
                        console.warn('Background music failed to play:', e);
                    });
                    musicStarted = true;
                } catch (e) {
                    console.warn('Background music error:', e);
                }
            },
            
            stopBackgroundMusic() {
                if (!backgroundMusic) return;
                
                try {
                    backgroundMusic.pause();
                    backgroundMusic.currentTime = 0;
                    musicStarted = false;
                } catch (e) {
                    console.warn('Background music stop error:', e);
                }
            },
            
            playEndGameSound() {
                if (!soundEnabled || !endGameSound) return;
                
                try {
                    endGameSound.currentTime = 0;
                    endGameSound.play().catch(e => {
                        console.warn('End game sound failed to play:', e);
                    });
                } catch (e) {
                    console.warn('End game sound error:', e);
                }
            },
            
            playBrickHit() {
                if (!audioContext || !soundEnabled) return;
                
                // Dull thump sound
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
                oscillator.type = 'square';
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            },
            
            playBrickBreak() {
                if (!audioContext || !soundEnabled) return;
                
                // Glass shattering sound
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const oscillator3 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                // Multiple high frequencies for glass-like sound
                oscillator1.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator2.frequency.setValueAtTime(1200, audioContext.currentTime);
                oscillator3.frequency.setValueAtTime(1600, audioContext.currentTime);
                
                oscillator1.type = 'triangle';
                oscillator2.type = 'triangle';
                oscillator3.type = 'triangle';
                
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(400, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator1.connect(filter);
                oscillator2.connect(filter);
                oscillator3.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator1.start();
                oscillator2.start();
                oscillator3.start();
                
                oscillator1.stop(audioContext.currentTime + 0.3);
                oscillator2.stop(audioContext.currentTime + 0.3);
                oscillator3.stop(audioContext.currentTime + 0.3);
            },
            
            playLifeLost() {
                if (!audioContext || !soundEnabled) return;
                
                // High pitch violin screech
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                oscillator.frequency.setValueAtTime(1200, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(2000, audioContext.currentTime + 0.5);
                oscillator.type = 'sawtooth';
                
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(1500, audioContext.currentTime);
                filter.Q.setValueAtTime(10, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.8);
            },
            
            playExplosion() {
                if (!soundEnabled || !explosionSound) return;
                
                try {
                    explosionSound.currentTime = 0;
                    explosionSound.play().catch(e => {
                        console.warn('Explosion sound failed to play:', e);
                    });
                } catch (e) {
                    console.warn('Explosion sound error:', e);
                }
            },
            
            toggleSound() {
                soundEnabled = !soundEnabled;
                
                // Handle background music based on sound state
                if (!soundEnabled) {
                    this.stopBackgroundMusic();
                } else if (gameState === 'playing' || gameState === 'waiting') {
                    // Only restart music if we're in an active game state
                    if (gameState === 'playing') {
                        this.startBackgroundMusic();
                    }
                }
                
                return soundEnabled;
            }
        };
        
        // Star system for spooky background
        const stars = [];
        
        // Initialize stars
        function initStars() {
            for (let i = 0; i < 75; i++) {
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 0.5 + 0.2,
                    opacity: Math.random() * 0.7 + 0.3,
                    twinklePhase: Math.random() * Math.PI * 2,
                    twinkleSpeed: Math.random() * 0.02 + 0.01
                });
            }
        }
        
        // Update stars
        function updateStars() {
            for (let star of stars) {
                star.x -= star.speed;
                star.twinklePhase += star.twinkleSpeed;
                star.opacity = 0.3 + 0.7 * (Math.sin(star.twinklePhase) * 0.5 + 0.5);
                
                // Wrap around when star exits left side
                if (star.x < -5) {
                    star.x = CANVAS_WIDTH + 5;
                    star.y = Math.random() * CANVAS_HEIGHT;
                }
            }
        }
        
        // Draw stars
        function drawStars() {
            for (let star of stars) {
                ctx.globalAlpha = star.opacity;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = true;
                    useMouseControl = false;
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    keys.right = true;
                    useMouseControl = false;
                    e.preventDefault();
                    break;
                case 'Space':
                    keys.space = true;
                    e.preventDefault();
                    break;
                case 'KeyB':
                    if (gameState === 'playing' && !ball.onPaddle) {
                        explodeBall();
                    }
                    e.preventDefault();
                    break;
                case 'KeyM':
                    toggleSound();
                    e.preventDefault();
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'Space':
                    keys.space = false;
                    break;
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            useMouseControl = true;
        });
        
        // Leaderboard Management Functions
        function loadLeaderboard() {
            try {
                // Try to load from new key first
                let saved = localStorage.getItem(LEADERBOARD_KEY);
                if (saved) {
                    leaderboard = JSON.parse(saved);
                } else {
                    // Check for old key and migrate
                    const oldSaved = localStorage.getItem(OLD_LEADERBOARD_KEY);
                    if (oldSaved) {
                        leaderboard = JSON.parse(oldSaved);
                        // Save to new key
                        localStorage.setItem(LEADERBOARD_KEY, oldSaved);
                        // Remove old key
                        localStorage.removeItem(OLD_LEADERBOARD_KEY);
                        console.log('Migrated leaderboard from Adaptive Breakout to Spooky Breakout');
                    } else {
                        leaderboard = [];
                    }
                }
            } catch (e) {
                console.warn('Failed to load leaderboard:', e);
                leaderboard = [];
            }
        }
        
        function saveLeaderboard() {
            try {
                localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboard));
            } catch (e) {
                console.warn('Failed to save leaderboard:', e);
            }
        }
        
        function isHighScore(score) {
            if (leaderboard.length < MAX_LEADERBOARD_ENTRIES) {
                return true;
            }
            return score > leaderboard[leaderboard.length - 1].score;
        }
        
        function addToLeaderboard(name, score) {
            const entry = {
                name: name.toUpperCase().substring(0, 3),
                score: score,
                date: Date.now()
            };
            
            leaderboard.push(entry);
            leaderboard.sort((a, b) => b.score - a.score);
            
            if (leaderboard.length > MAX_LEADERBOARD_ENTRIES) {
                leaderboard = leaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
            }
            
            saveLeaderboard();
            updateLeaderboardDisplay();
        }
        
        function updateLeaderboardDisplay() {
            const listElement = document.getElementById('leaderboardList');
            listElement.innerHTML = '';
            
            // Always show exactly 10 entries
            for (let i = 0; i < MAX_LEADERBOARD_ENTRIES; i++) {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'leaderboard-entry';
                
                const rankSpan = document.createElement('span');
                rankSpan.className = 'leaderboard-rank';
                rankSpan.textContent = `${i + 1}.`;
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'leaderboard-name';
                
                const scoreSpan = document.createElement('span');
                scoreSpan.className = 'leaderboard-score';
                
                if (i < leaderboard.length) {
                    // Real entry
                    const entry = leaderboard[i];
                    nameSpan.textContent = entry.name;
                    scoreSpan.textContent = entry.score.toLocaleString();
                } else {
                    // Empty slot
                    entryDiv.classList.add('empty');
                    nameSpan.textContent = '---';
                    scoreSpan.textContent = '---';
                }
                
                entryDiv.appendChild(rankSpan);
                entryDiv.appendChild(nameSpan);
                entryDiv.appendChild(scoreSpan);
                
                listElement.appendChild(entryDiv);
            }
        }
        
        function resetLeaderboard() {
            if (confirm('Are you sure you want to reset all high scores? This cannot be undone.')) {
                leaderboard = [];
                saveLeaderboard();
                updateLeaderboardDisplay();
            }
        }
        
        function validatePlayerName(name) {
            // Remove non-alphanumeric characters and limit to 3 characters
            return name.replace(/[^A-Z0-9]/g, '').substring(0, 3);
        }
        
        // Initialize game
        function init() {
            // Log version information for debugging
            console.log(`Spooky Breakout v${GAME_VERSION} - AI-Enhanced Brick Ball Game`);
            console.log('Game initialized successfully');
            
            // Update version display
            document.getElementById('version').textContent = GAME_VERSION;
            
            // Initialize sound system
            soundManager.init();
            
            // Load game over image
            gameOverImage = new Image();
            gameOverImage.onload = function() {
                imageLoaded = true;
                console.log('Game over image loaded successfully');
            };
            gameOverImage.onerror = function() {
                console.warn('Failed to load game over image');
                imageLoaded = false;
            };
            gameOverImage.src = 'assets/sprites/face.png';
            
            // Initialize leaderboard
            loadLeaderboard();
            updateLeaderboardDisplay();
            
            // Initialize star field
            initStars();
            
            createLevel(level);
            resetBall();
            gameLoop();
        }
        
        // Create level with bricks
        function createLevel(levelNum) {
            bricks = [];
            const typeKeys = Object.keys(brickTypes);
            
            for (let row = 0; row < BRICK_ROWS; row++) {
                bricks[row] = [];
                for (let col = 0; col < BRICK_COLS; col++) {
                    const typeIndex = Math.min(row, typeKeys.length - 1);
                    const type = typeKeys[typeIndex];
                    
                    bricks[row][col] = {
                        x: col * (BRICK_WIDTH + BRICK_PADDING) + BRICK_OFFSET_LEFT,
                        y: row * (BRICK_HEIGHT + BRICK_PADDING) + BRICK_OFFSET_TOP,
                        width: BRICK_WIDTH,
                        height: BRICK_HEIGHT,
                        type: type,
                        hits: brickTypes[type].hits,
                        maxHits: brickTypes[type].hits,
                        visible: true
                    };
                }
            }
            
            playerMetrics.levelStartTime = Date.now();
        }
        
        // Reset ball to paddle
        function resetBall() {
            ball.x = paddle.x + paddle.width / 2;
            ball.y = paddle.y - BALL_RADIUS - 1;
            ball.vx = 0;
            ball.vy = 0;
            ball.onPaddle = true;
            gameState = 'waiting';
        }
        
        // Launch ball
        function launchBall() {
            if (ball.onPaddle) {
                ball.onPaddle = false;
                ball.vx = (Math.random() - 0.5) * 4;
                ball.vy = -ball.speed;
                gameState = 'playing';
                
                // Start background music when gameplay begins
                soundManager.startBackgroundMusic();
            }
        }
        
        // Update paddle position
        function updatePaddle() {
            if (useMouseControl) {
                paddle.x = mouseX - paddle.width / 2;
            } else {
                if (keys.left && paddle.x > 0) {
                    paddle.x -= paddle.speed;
                }
                if (keys.right && paddle.x < CANVAS_WIDTH - paddle.width) {
                    paddle.x += paddle.speed;
                }
            }
            
            // Keep paddle in bounds
            paddle.x = Math.max(0, Math.min(CANVAS_WIDTH - paddle.width, paddle.x));
            
            // Move ball with paddle when on paddle
            if (ball.onPaddle) {
                ball.x = paddle.x + paddle.width / 2;
            }
        }
        
        // Update ball position and physics
        function updateBall() {
            if (ball.onPaddle) return;
            
            // Apply AI physics assistance
            applyPhysicsAssistance();
            
            ball.x += ball.vx;
            ball.y += ball.vy;
            
            // Wall collisions
            if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= CANVAS_WIDTH) {
                ball.vx = -ball.vx;
                ball.x = Math.max(ball.radius, Math.min(CANVAS_WIDTH - ball.radius, ball.x));
                playerMetrics.totalBallBounces++;
            }
            
            if (ball.y - ball.radius <= 0) {
                ball.vy = -ball.vy;
                ball.y = ball.radius;
                playerMetrics.totalBallBounces++;
            }
            
            // Ball fell off bottom
            if (ball.y - ball.radius > CANVAS_HEIGHT) {
                loseLife();
                return;
            }
            
            // Paddle collision
            checkPaddleBallCollision();
            
            // Brick collisions
            checkBrickCollisions();
        }
        
        // Check paddle-ball collision
        function checkPaddleBallCollision() {
            // First try AI assistance for struggling players
            if (applyCollisionAssistance()) {
                return; // AI assistance handled the collision
            }
            
            // Normal collision detection
            if (ball.y + ball.radius >= paddle.y &&
                ball.y - ball.radius <= paddle.y + paddle.height &&
                ball.x >= paddle.x &&
                ball.x <= paddle.x + paddle.width) {
                
                // Calculate hit position on paddle (-1 to 1)
                const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                
                // Adjust ball angle based on hit position
                ball.vx = hitPos * 5;
                ball.vy = -Math.abs(ball.vy);
                
                // Ensure minimum upward velocity
                if (Math.abs(ball.vy) < 3) {
                    ball.vy = -3;
                }
                
                ball.y = paddle.y - ball.radius;
                playerMetrics.paddleHits++;
                playerMetrics.totalBallBounces++;
            }
        }
        
        // Check brick collisions
        function checkBrickCollisions() {
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    if (!brick.visible) continue;
                    
                    if (ball.x + ball.radius >= brick.x &&
                        ball.x - ball.radius <= brick.x + brick.width &&
                        ball.y + ball.radius >= brick.y &&
                        ball.y - ball.radius <= brick.y + brick.height) {
                        
                        // Determine collision side
                        const overlapLeft = (ball.x + ball.radius) - brick.x;
                        const overlapRight = (brick.x + brick.width) - (ball.x - ball.radius);
                        const overlapTop = (ball.y + ball.radius) - brick.y;
                        const overlapBottom = (brick.y + brick.height) - (ball.y - ball.radius);
                        
                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                        
                        if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                            ball.vx = -ball.vx;
                        } else {
                            ball.vy = -ball.vy;
                        }
                        
                        // Damage brick
                        brick.hits--;
                        playerMetrics.bricksHit++;
                        
                        if (brick.hits <= 0) {
                            brick.visible = false;
                            score += brickTypes[brick.type].points;
                            
                            // Play glass shattering sound for brick break
                            soundManager.playBrickBreak();
                            
                            // Create particles
                            createParticles(brick.x + brick.width / 2, brick.y + brick.height / 2, brickTypes[brick.type].color);
                            
                            // Screen shake
                            addScreenShake(2, 100);
                            
                            // AI-enhanced power-up spawning
                            if (shouldSpawnHelpfulPowerUp()) {
                                spawnPowerUp(brick.x + brick.width / 2, brick.y + brick.height / 2);
                            }
                        } else {
                            // Play dull thump sound for brick hit (not destroyed)
                            soundManager.playBrickHit();
                        }
                        
                        // Check if level complete
                        if (isLevelComplete()) {
                            level++;
                            createLevel(level);
                            resetBall();
                        }
                        
                        return; // Only hit one brick per frame
                    }
                }
            }
        }
        
        // Check if level is complete
        function isLevelComplete() {
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    if (bricks[row][col].visible) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        // Lose a life
        function loseLife() {
            lives--;
            playerMetrics.ballsLost++;
            playerMetrics.paddleMisses++;
            
            // Play high pitch violin screech for life lost
            soundManager.playLifeLost();
            
            const now = Date.now();
            if (now - playerMetrics.lastBallLoss < 5000) {
                playerMetrics.consecutiveDeaths++;
            } else {
                playerMetrics.consecutiveDeaths = 1;
            }
            playerMetrics.lastBallLoss = now;
            
            // Check if level is complete before checking game over
            // This allows finishing the level even with 0 lives
            if (isLevelComplete()) {
                level++;
                createLevel(level);
                resetBall();
                return; // Don't check for game over if level is complete
            }
            
            if (lives <= 0) {
                gameOver();
            } else {
                resetBall();
            }
        }
        
        // Game over
        function gameOver() {
            gameState = 'gameOver';
            
            // Stop background music and play dramatic end game sound
            soundManager.stopBackgroundMusic();
            soundManager.playEndGameSound();
            
            // Check if this is a high score
            isNewHighScore = isHighScore(score);
            
            document.getElementById('finalScore').textContent = score;
            
            if (isNewHighScore) {
                showNameEntry();
            } else {
                document.getElementById('gameOverScreen').style.display = 'block';
            }
        }
        
        // Show name entry for high score
        function showNameEntry() {
            const gameOverScreen = document.getElementById('gameOverScreen');
            
            // Create name entry HTML
            gameOverScreen.innerHTML = `
                <h2>NEW HIGH SCORE!</h2>
                <div>Final Score: <span id="finalScore">${score}</span></div>
                <div class="name-entry">
                    <div style="margin-bottom: 10px;">Enter your name (3 characters):</div>
                    <input type="text" id="playerNameInput" maxlength="3" placeholder="ABC" 
                           style="text-transform: uppercase;" autocomplete="off">
                </div>
                <button onclick="submitHighScore()" id="submitButton">Submit Score</button>
                <button onclick="skipHighScore()">Skip</button>
            `;
            
            gameOverScreen.style.display = 'block';
            
            // Focus on input and add event listeners
            const nameInput = document.getElementById('playerNameInput');
            nameInput.focus();
            
            // Handle input validation
            nameInput.addEventListener('input', function(e) {
                let value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
                e.target.value = value;
                
                // Enable/disable submit button
                const submitButton = document.getElementById('submitButton');
                submitButton.disabled = value.length === 0;
            });
            
            // Handle Enter key
            nameInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && e.target.value.length > 0) {
                    submitHighScore();
                }
            });
        }
        
        // Submit high score
        function submitHighScore() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim();
            
            if (name.length > 0) {
                addToLeaderboard(name, score);
                showGameOverScreen();
            }
        }
        
        // Skip high score entry
        function skipHighScore() {
            showGameOverScreen();
        }
        
        // Show regular game over screen
        function showGameOverScreen() {
            const gameOverScreen = document.getElementById('gameOverScreen');
            
            gameOverScreen.innerHTML = `
                <h2>Game Over!</h2>
                <div>Final Score: <span id="finalScore">${score}</span></div>
                <button onclick="restartGame()">Play Again</button>
            `;
            
            isNewHighScore = false;
            playerName = '';
        }
        
        // Restart game
        function restartGame() {
            lives = 3;
            score = 0;
            level = 1;
            gameState = 'waiting';
            
            // Reset metrics
            Object.keys(playerMetrics).forEach(key => {
                if (typeof playerMetrics[key] === 'number') {
                    playerMetrics[key] = 0;
                }
            });
            playerMetrics.levelStartTime = Date.now();
            
            // Reset power-ups
            powerUps.length = 0;
            activePowerUps.length = 0;
            
            // Reset paddle and ball
            paddle.width = paddle.originalWidth;
            ball.speed = ball.originalSpeed;
            
            document.getElementById('gameOverScreen').style.display = 'none';
            createLevel(level);
            resetBall();
        }
        
        // Spawn power-up
        function spawnPowerUp(x, y) {
            const types = Object.keys(powerUpTypes);
            const type = types[Math.floor(Math.random() * types.length)];
            
            powerUps.push({
                x: x,
                y: y,
                type: type,
                width: 30,
                height: 15,
                speed: 2
            });
        }
        
        // Update power-ups
        function updatePowerUps() {
            // Update falling power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.speed;
                
                // Check collision with paddle
                if (powerUp.y + powerUp.height >= paddle.y &&
                    powerUp.y <= paddle.y + paddle.height &&
                    powerUp.x + powerUp.width >= paddle.x &&
                    powerUp.x <= paddle.x + paddle.width) {
                    
                    collectPowerUp(powerUp);
                    powerUps.splice(i, 1);
                    continue;
                }
                
                // Remove if off screen
                if (powerUp.y > CANVAS_HEIGHT) {
                    powerUps.splice(i, 1);
                }
            }
            
            // Update active power-ups
            const now = Date.now();
            for (let i = activePowerUps.length - 1; i >= 0; i--) {
                const powerUp = activePowerUps[i];
                if (now >= powerUp.endTime) {
                    removePowerUpEffect(powerUp.type);
                    activePowerUps.splice(i, 1);
                }
            }
        }
        
        // Collect power-up
        function collectPowerUp(powerUp) {
            applyPowerUpEffect(powerUp.type);
            addScreenShake(3, 150);
        }
        
        // Apply power-up effect
        function applyPowerUpEffect(type) {
            const now = Date.now();
            const duration = powerUpTypes[type].duration;
            
            // Remove existing effect of same type
            for (let i = activePowerUps.length - 1; i >= 0; i--) {
                if (activePowerUps[i].type === type) {
                    activePowerUps.splice(i, 1);
                }
            }
            
            // Add new effect
            activePowerUps.push({
                type: type,
                endTime: now + duration
            });
            
            // Apply immediate effects
            switch(type) {
                case 'widePaddle':
                    paddle.width = paddle.originalWidth * 1.5;
                    break;
                case 'slowBall':
                    ball.speed = ball.originalSpeed * 0.7;
                    // Adjust current velocity
                    const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    if (currentSpeed > 0) {
                        const ratio = ball.speed / currentSpeed;
                        ball.vx *= ratio;
                        ball.vy *= ratio;
                    }
                    break;
            }
        }
        
        // Remove power-up effect
        function removePowerUpEffect(type) {
            switch(type) {
                case 'widePaddle':
                    paddle.width = paddle.originalWidth;
                    break;
                case 'slowBall':
                    ball.speed = ball.originalSpeed;
                    // Adjust current velocity
                    const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    if (currentSpeed > 0) {
                        const ratio = ball.speed / currentSpeed;
                        ball.vx *= ratio;
                        ball.vy *= ratio;
                    }
                    break;
            }
        }
        
        // Create particles
        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 1.0,
                    decay: 0.02,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        // Create explosion particles
        function createExplosionParticles(x, y) {
            for (let i = 0; i < 25; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    decay: 0.015,
                    color: ['#ff4444', '#ff8800', '#ffaa00', '#cc0000'][Math.floor(Math.random() * 4)],
                    size: Math.random() * 6 + 3
                });
            }
        }
        
        // Explode ball function
        function explodeBall() {
            const explosionRadius = 180;
            let bricksDestroyed = 0;
            
            // Play explosion sound
            soundManager.playExplosion();
            
            // Create massive explosion particles
            createExplosionParticles(ball.x, ball.y);
            
            // Add intense screen shake
            addScreenShake(8, 400);
            
            // Check all bricks for destruction within explosion radius
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    if (!brick.visible) continue;
                    
                    // Calculate distance from explosion center to brick center
                    const brickCenterX = brick.x + brick.width / 2;
                    const brickCenterY = brick.y + brick.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(ball.x - brickCenterX, 2) + 
                        Math.pow(ball.y - brickCenterY, 2)
                    );
                    
                    // Destroy brick if within explosion radius
                    if (distance <= explosionRadius) {
                        brick.visible = false;
                        score += brickTypes[brick.type].points;
                        bricksDestroyed++;
                        
                        // Create particles for each destroyed brick
                        createParticles(brickCenterX, brickCenterY, brickTypes[brick.type].color);
                    }
                }
            }
            
            // Update player metrics
            playerMetrics.bricksHit += bricksDestroyed;
            
            // Check if level is complete before losing life
            if (isLevelComplete()) {
                level++;
                createLevel(level);
                resetBall();
                return; // Don't lose a life if level is complete
            }
            
            // Lose a life (ball is destroyed in explosion)
            loseLife();
        }
        
        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;
                particle.size *= 0.98;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        // Add screen shake
        function addScreenShake(intensity, duration) {
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
            screenShake.duration = Math.max(screenShake.duration, duration);
        }
        
        // Update screen shake
        function updateScreenShake() {
            if (screenShake.duration > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.duration -= 16; // Assuming 60fps
                screenShake.intensity *= 0.9;
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
                screenShake.intensity = 0;
            }
        }
        
        // Handle input
        function handleInput() {
            if (keys.space && gameState === 'waiting') {
                launchBall();
            }
        }
        
        // Update game
        function update() {
            handleInput();
            updatePaddle();
            updateBall();
            updatePowerUps();
            updateParticles();
            updateScreenShake();
            updateStars();
            updateUI();
        }
        
        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('level').textContent = level;
            
            // Update power-up timers
            const timersDiv = document.getElementById('powerUpTimers');
            timersDiv.innerHTML = '';
            
            const now = Date.now();
            activePowerUps.forEach(powerUp => {
                const timeLeft = Math.max(0, powerUp.endTime - now);
                const seconds = Math.ceil(timeLeft / 1000);
                
                const timerDiv = document.createElement('div');
                timerDiv.className = 'power-up-timer';
                timerDiv.textContent = `${powerUpTypes[powerUp.type].name}: ${seconds}s`;
                timerDiv.style.borderColor = powerUpTypes[powerUp.type].color;
                timersDiv.appendChild(timerDiv);
            });
        }
        
        // Render game
        function render() {
            // Clear canvas with screen shake
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // If game over, show spooky face image instead of normal game
            if (gameState === 'gameOver' && imageLoaded && gameOverImage) {
                // Draw the face image to fill the entire canvas
                ctx.drawImage(gameOverImage, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.restore();
                return; // Don't draw normal game elements
            }
            
            // Draw stars behind everything
            drawStars();
            
            // Draw bricks
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    if (!brick.visible) continue;
                    
                    const alpha = brick.hits / brick.maxHits;
                    const color = brickTypes[brick.type].color;
                    
                    ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    
                    // Add border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                }
            }
            
            // Draw paddle
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            // Add paddle glow
            ctx.shadowColor = '#cc0000';
            ctx.shadowBlur = 10;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.shadowBlur = 0;
            
            // Draw ball
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Add ball glow
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Draw power-ups
            powerUps.forEach(powerUp => {
                ctx.fillStyle = powerUpTypes[powerUp.type].color;
                ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                
                // Add glow
                ctx.shadowColor = powerUpTypes[powerUp.type].color;
                ctx.shadowBlur = 8;
                ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                ctx.shadowBlur = 0;
            });
            
            // Draw particles
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw waiting message
            if (gameState === 'waiting') {
                ctx.fillStyle = '#ffff00';
                ctx.font = '24px ScaryFont, Courier New, monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Press SPACE to launch ball', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            }
            
            ctx.restore();
        }
        
        // Game loop
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (gameState !== 'gameOver') {
                update();
            }
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Toggle sound function (global for button onclick)
        function toggleSound() {
            const enabled = soundManager.toggleSound();
            const button = document.getElementById('soundToggle');
            button.textContent = enabled ? 'üîä Sound: ON' : 'üîá Sound: OFF';
        }
        
        // Start the game
        init();
    </script>
</body>
</html>
